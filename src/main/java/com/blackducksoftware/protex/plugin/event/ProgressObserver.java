/*******************************************************************************
 * Copyright (C) 2016 Black Duck Software, Inc.
 * http://www.blackducksoftware.com/
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *******************************************************************************/
package com.blackducksoftware.protex.plugin.event;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Observable;
import java.util.Observer;

import com.blackducksoftware.protex.plugin.BDSToolPlumbing.ClientDriverNotifier;
import com.blackducksoftware.protex.plugin.BlackDuckCommand;
import com.blackducksoftware.protex.plugin.BlackDuckCommand.State;
import com.blackducksoftware.protex.plugin.BuildToolIntegrationException;

/**
 * A bridge between the client driver's {@code Observable} model and the analysis event model.
 *
 * @author jgustie
 */
public class ProgressObserver implements Observer {

    /**
     * The collection of registered listeners.
     */
    private final Iterable<AnalysisListener> listeners;

    public ProgressObserver(Iterable<AnalysisListener> listeners) {
        this.listeners = listeners;
    }

    @Override
    public void update(Observable o, Object arg) {
        // Route the observable based on type, ignore anything we don't recognize instead of failing
        if (o instanceof BlackDuckCommand) {
            updateCommand((BlackDuckCommand) o, arg);
        } else if (ClientDriverNotifier.valueOf(o) == ClientDriverNotifier.PROGRESS) {
            // Validate that we got a Map
            checkState(arg instanceof Map, "expected java.util.Map argument");

            // The map may contain FlexCaseInsensitiveObject keys...convert to strings
            Map<String, Object> state = new LinkedHashMap<String, Object>(((Map<?, ?>) arg).size());
            for (Entry<?, ?> entry : ((Map<?, ?>) arg).entrySet()) {
                state.put(entry.getKey().toString(), entry.getValue());
            }
            updateProgress(state);
        }
    }

    /**
     * Handles notifications generated by Black Duck commands. Notifications are generated for each state transition
     * (e.g. from {@code INITIATED} to {@code SUCCEEDED} or {@code NEW} to {@code INITIATED}).
     */
    private void updateCommand(BlackDuckCommand command, Object arg) {
        Map<String, Object> state = Collections.emptyMap();
        if (command.state() == State.INITIATED) {
            // Initiation notifications can only pass null, see BlackDuckCommand#notifyInitiated
            checkState(arg == null, "initated with non-null argument");
            ListenerDispatch.INITIATED.dispatch(listeners, new AnalysisEvent(state));
        } else if (command.state() == State.SUCCEEDED) {
            // Success notifications can only pass null, see BlackDuckCommand#notifySucceeded
            checkState(arg == null, "succeeded with non-null argument");
            ListenerDispatch.SUCCEEDED.dispatch(listeners, new AnalysisEvent(state));
        } else if (command.state() == State.FAILED) {
            // Failure notifications can only pass BTIEs, see BlackDuckCommand#notifyFailed
            checkState(arg instanceof BuildToolIntegrationException, "failed with non-BTIE argument");
            state = Collections.singletonMap("exception", arg);
            ListenerDispatch.FAILED.dispatch(listeners, new AnalysisEvent(state));
        }
    }

    /**
     * Handles notifications generated by the Black Duck client progress notifier.
     */
    private void updateProgress(Map<String, ?> progress) {
        // TODO Check operation_number == 1 instead?
        String file = (String) progress.get("file");
        if (file != null && file.equals("... assessing work ...")) {
            ListenerDispatch.STARTED.dispatch(listeners, new AnalysisEvent(progress));
        } else {
            ListenerDispatch.PROGRESSED.dispatch(listeners, new AnalysisEvent(progress));
        }
    }

    /**
     * Helper to clean up state checks.
     */
    private static void checkState(boolean expression, String message) {
        if (!expression) {
            throw new IllegalStateException(message);
        }
    }

    /**
     * An enumeration of the supported methods available on the analysis listener interface.
     */
    private enum ListenerDispatch {
        INITIATED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisInitiated(event);
            }
        },
        STARTED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisStarted(event);
            }
        },
        PROGRESSED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisProgressed(event);
            }
        },
        SUCCEEDED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisSucceeded(event);
            }
        },
        FAILED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisFailed(event);
            }
        };

        protected void call(AnalysisListener listener, AnalysisEvent event) {
            // Enums cannot declare "real" abstract methods
            throw new AbstractMethodError();
        }

        /**
         * Invokes the appropriate listener method on all of the supplied listeners.
         */
        protected void dispatch(Iterable<AnalysisListener> listeners, AnalysisEvent event) {
            for (AnalysisListener listener : listeners) {
                call(listener, event);
            }
        }
    }
}
