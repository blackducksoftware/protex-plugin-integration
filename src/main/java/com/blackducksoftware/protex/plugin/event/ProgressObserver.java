/*
 * Protex Plugin Integration
 * Copyright (C) 2015 Black Duck Software, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */
package com.blackducksoftware.protex.plugin.event;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Observable;
import java.util.Observer;

import com.blackducksoftware.protex.plugin.BDSToolPlumbing.ClientDriverNotifier;
import com.blackducksoftware.protex.plugin.BlackDuckCommand;
import com.blackducksoftware.protex.plugin.BlackDuckCommand.State;
import com.blackducksoftware.protex.plugin.BuildToolIntegrationException;

/**
 * A bridge between the client driver's {@code Observable} model and the analysis event model.
 *
 * @author jgustie
 */
public class ProgressObserver implements Observer {

    /**
     * The collection of registered listeners.
     */
    private final Iterable<AnalysisListener> listeners;

    public ProgressObserver(Iterable<AnalysisListener> listeners) {
        this.listeners = listeners;
    }

    @Override
    public void update(Observable o, Object arg) {
        // Route the observable based on type, ignore anything we don't recognize instead of failing
        if (o instanceof BlackDuckCommand) {
            updateCommand((BlackDuckCommand) o, arg);
        } else if (ClientDriverNotifier.valueOf(o) == ClientDriverNotifier.PROGRESS) {
            // Validate that we got a Map
            checkState(arg instanceof Map, "expected java.util.Map argument");

            // The map may contain FlexCaseInsensitiveObject keys...convert to strings
            Map<String, Object> state = new LinkedHashMap<String, Object>(((Map<?, ?>) arg).size());
            for (Entry<?, ?> entry : ((Map<?, ?>) arg).entrySet()) {
                state.put(entry.getKey().toString(), entry.getValue());
            }
            updateProgress(state);
        }
    }

    /**
     * Handles notifications generated by Black Duck commands. Notifications are generated for each state transition
     * (e.g. from {@code INITIATED} to {@code SUCCEEDED} or {@code NEW} to {@code INITIATED}).
     */
    private void updateCommand(BlackDuckCommand command, Object arg) {
        Map<String, Object> state = Collections.emptyMap();
        if (command.state() == State.INITIATED) {
            // Initiation notifications can only pass null, see BlackDuckCommand#notifyInitiated
            checkState(arg == null, "initated with non-null argument");
            ListenerDispatch.INITIATED.dispatch(listeners, new AnalysisEvent(state));
        } else if (command.state() == State.SUCCEEDED) {
            // Success notifications can only pass null, see BlackDuckCommand#notifySucceeded
            checkState(arg == null, "succeeded with non-null argument");
            ListenerDispatch.SUCCEEDED.dispatch(listeners, new AnalysisEvent(state));
        } else if (command.state() == State.FAILED) {
            // Failure notifications can only pass BTIEs, see BlackDuckCommand#notifyFailed
            checkState(arg instanceof BuildToolIntegrationException, "failed with non-BTIE argument");
            state = Collections.singletonMap("exception", arg);
            ListenerDispatch.FAILED.dispatch(listeners, new AnalysisEvent(state));
        }
    }

    /**
     * Handles notifications generated by the Black Duck client progress notifier.
     */
    private void updateProgress(Map<String, ?> progress) {
        // TODO Check operation_number == 1 instead?
        String file = (String) progress.get("file");
        if (file != null && file.equals("... assessing work ...")) {
            ListenerDispatch.STARTED.dispatch(listeners, new AnalysisEvent(progress));
        } else {
            ListenerDispatch.PROGRESSED.dispatch(listeners, new AnalysisEvent(progress));
        }
    }

    /**
     * Helper to clean up state checks.
     */
    private static void checkState(boolean expression, String message) {
        if (!expression) {
            throw new IllegalStateException(message);
        }
    }

    /**
     * An enumeration of the supported methods available on the analysis listener interface.
     */
    private enum ListenerDispatch {
        INITIATED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisInitiated(event);
            }
        },
        STARTED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisStarted(event);
            }
        },
        PROGRESSED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisProgressed(event);
            }
        },
        SUCCEEDED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisSucceeded(event);
            }
        },
        FAILED {
            @Override
            protected void call(AnalysisListener listener, AnalysisEvent event) {
                listener.analysisFailed(event);
            }
        };

        protected void call(AnalysisListener listener, AnalysisEvent event) {
            // Enums cannot declare "real" abstract methods
            throw new AbstractMethodError();
        }

        /**
         * Invokes the appropriate listener method on all of the supplied listeners.
         */
        protected void dispatch(Iterable<AnalysisListener> listeners, AnalysisEvent event) {
            for (AnalysisListener listener : listeners) {
                call(listener, event);
            }
        }
    }
}
